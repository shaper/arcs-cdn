<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!-- firebase -->
<script src="https://www.gstatic.com/firebasejs/4.2.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.2.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.2.0/firebase-database.js"></script>

<script>
(scope => {
  //let version = typeof Arcs === 'undefined' || !Arcs.version ? '/' : Arcs.version.replace(/\./g, '_');
  let db_version = '0_2_1';
  let firebaseConfig = {
    apiKey: "AIzaSyBme42moeI-2k8WgXh-6YK_wYyjEXo4Oz8",
    authDomain: "arcs-storage.firebaseapp.com",
    databaseURL: "https://arcs-storage.firebaseio.com",
    projectId: "arcs-storage",
    storageBucket: "arcs-storage.appspot.com",
    messagingSenderId: "779656349412"
  };
  let db = firebase.initializeApp(firebaseConfig/*, 'arcs-storage'*/).database().ref(db_version);

  /* for debugging only */
  db.dump = () => db.once('value').then(snap => console.log(db.data = snap.val()));
  scope.db = db;

  class ArcStore extends XenBase {
    static get observedAttributes() { return ['key','metadata','users','arc','viewtags']; }
    _didMount() {
      this._watching = new Set();
      this._watchArcs();
      this._watchUsers();
    }
    _update(props, state, lastProps) {
      if ('key' in props && props.key === null) {
        this._createKey();
      }
      if (props.key && props.key !== lastProps.key) {
        this._watch();
      }
      if (props.arc) {
        this._watchViews(props.arc);
      }
      if (props.metadata && lastProps.metadata !== props.metadata) {
        this._arcChild.set(props.metadata);
      }
      if (props.users && lastProps.users !== props.users) {
        this._usersChild.set(props.users);
      }
    }
    // All (versioned) storage
    get _db() {
      return db;
    }
    async dump(path) {
      let node = path ? this._db.child(path) : this._db;
      let data = (await node.once('value')).val();
      ArcStore.log(`dump`, node.toString(), data);
    }
    // All arcs storage (arcs)
    get _arcsChild() {
      return this._db.child('arcs');
    }
    _watchArcs() {
      this._arcsOff && this._arcsOff();
      let node = this._arcsChild;
      ArcStore.log(`watching arcs`);
      let handle = node.on('value', snap => {
        let data = snap.val();
        ArcStore.log(`retrieve arcs value`, data);
        data && this._fire('arcs', data);
      });
      this._arcsOff = () => node.off(handle);
    }
    // Single arc storage (arcs/[key])
    _createKey() {
      let defaults = {
        description: Arcs.utils.randomName()
      };
      let key = this._arcsChild.push(defaults).key;
      ArcStore.log('createKey', key);
      this.dispatchEvent(new CustomEvent('key', {detail: key}));
    }
    get _arcChild() {
      return this._arcsChild.child(this._props.key)
    }
    _child(path) {
      return path ? this._arcChild.child(path) : this._arcChild;
    }
    _store(path, data) {
      ArcStore.log('store', path, data);
      this._child(path).set(data);
    }
    async fetch(path) {
      data = (await this._child(path).once('value')).val();
      ArcStore.log(`fetch${path ? path : ''}`, data);
    }
    _watch() {
      this._off && this._off();
      let node = this._arcChild;
      ArcStore.log(`watching`, this._props.key);
      let handle = node.on('value', snap => {
        let data = snap.val();
        ArcStore.log(`retrieve arc [${this._props.key}]`, data);
        data && this._fire('metadata', data);
      });
      this._off = () => node.off(handle);
    }
    // All users storage (arcs)
    get _usersChild() {
      return this._db.child('users');
    }
    _watchUsers() {
      this._usersOff && this._usersOff();
      let node = this._usersChild;
      ArcStore.log(`watching users`);
      let handle = node.on('value', snap => {
        let data = snap.val();
        ArcStore.log(`retrieve users value`, data);
        this._fire('users', data);
      });
      this._usersOff = () => node.off(handle);
    }
    async _retrieveProfile(user) {
      let tasks = Object.keys(user.profiles).map(k => this._arcsChild.child(k).once('value'));
      let snaps = await Promise.all(tasks);
      let arcs = snaps.map(s => s.val());
      ArcStore.log("profile arcs", arcs);
    }
    //
    // views
    _watchViews(arc) {
      //ArcStore.log('resyncing views...', arc._viewTags);
      //if (this._viewWatches) {
      //  this._viewWatches.forEach(w => w());
      //}
      //this._viewWatches = [];
      arc._viewTags.forEach((tags, view) => {
        if (!tags || !tags.has('#nosync')) {
          let off = this._syncView(arc, tags, view);
          if (off) {
            //this._viewWatches.push(off);
          }
        }
      });
    }
    _syncView(arc, tags, view) {
      let viewId = this._getViewId(tags, view);
      // Make sure we only synchronize each view at most once.
      if (!this._watching.has(viewId)) {
        this._watching.add(viewId);
        // db node
        let node = this._arcChild.child(`views/${viewId}`);
        // force latest metadata
        let metadata = {
          type: view.type || null,
          name: view.name || null,
          tags: [...tags],
        };
        node.update({metadata});
        // watch the db
        node = node.child('values');
        let off = this._watchView(node, view, data => {
          // only store if change did not originate here
          if (!data.id.startsWith(arc.id)) {
            ArcStore.log('import view data from db', data);
            view.store ? view.store(data) : view.set(data);
          }
        });
        // watch the view
        view.on('change', change => {
          // only store if change originated here
          if (change.data && change.data.id.startsWith(arc.id)) {
            ArcStore.log('view changed', view, change);
            node.set(this._getViewData(view));
          }
        }, this);
        return off;
      }
    }
    _getViewId(tags, view) {
      let viewid = view.type.toString().replace(/ /g, '-').replace(/[\[\]]/g, '!');
      if (tags && [...tags].length) {
        viewid += '-' + [...tags][0].replace(/#/g, '');
      }
      return viewid;
    }
    _getViewData(view) {
      let data;
      if (view.toList) {
        data = view.toList();
      } else {
        let rawData = view._stored && view._stored.rawData || {};
        data = {
          id: view.id,
          rawData
        };
      }
      ArcStore.log('view data from Arc', view, data);
      return data;
    }
    _watchView(node, view, cb) {
      ArcStore.log('watching view', node.toString());
      let handle = node.on('value', snapshot => {
        let data = snapshot.val();
        ArcStore.log('view watch triggered', String(node), data);
        if (data && data.rawData) {
          cb(data);
        }
      });
      return () => node.off('value', handle);
    }
  }
  ArcStore.module = document.currentImport;
  ArcStore.log = XenBase.logFactory('ArcStore', '#a30000');
  customElements.define('arc-store', ArcStore);
})(this);
</script>
