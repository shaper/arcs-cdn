<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
(scope => {
  class PersistentUser extends XenBase {
    static get observedAttributes() { return ['id','user','key','arc']; }
    _update(props, state, lastProps, lastState) {
      if (props.user && !props.id) {
        // need a new user
        state.user = null;
        this._createUser(props.user);
      }
      // if we have an id, and props.user has mutated, write the mutations to the database
      if (props.id && props.user && props.user !== state.user && props.user !== lastProps.user) {
        PersistentUser.log('WRITING user (update)', props.user, state.user);
        this._usersdb.child(props.user.id).set(props.user);
      }
      // if we have a novel id and aren't already waiting, try to acquire user data from the database
      if (props.id && (!state.user || state.user.id !== props.id) && !state.connecting) {
        state.connecting = true;
        this._watchUser(props.id);
      }
      // if we were connecting, and have received a user from the database, then...
      if (state.connecting && state.user) {
        // we are done connecting
        state.connecting = false;
        // if we have acquired a user, but the data is stale, then...
        if (state.user.id !== props.id) {
          // discard the user
          state.user = null;
        }
      }
      // if we have a fresh (current Arc) key, store it for later processing
      if (props.key !== lastProps.key) {
        state.key = props.key;
      }
      // if we have a key to process, a user, and an arc, then...
      if (state.key && state.user && props.arc) {
        this._watchProfileViews(state.user, state.key, props.arc);
        // record that the user touched this arc
        this._userdb.child(`arcs/${state.key}`).update({
          touched: firebase.database.ServerValue.TIMESTAMP
        });
        // done processing key
        state.key = '';
      }
      if (state.user !== lastState.user) {
        // disable old watches, enable fresh ones as needed
        this._watchVisitedArcs(state.user);
      }
      // always upstream user
      this._fire('user', state.user);
    }
    get _usersdb() {
      return db.child('users');
    }
    get _userdb() {
      return this._usersdb.child(this._state.user.id);
    }
    _createUser(user) {
      user.id = this._usersdb.push().key;
      PersistentUser.log('WRITING user (createUser)', user);
      this._usersdb.child(user.id).set(user);
      this._setState({user});
    }
    async _watchUser(id) {
      this._unwatch();
      let node = this._usersdb.child(id);
      let user = (await node.once('value')).val();
      if (!user || !user.launcherKey || !user.id) {
        if (user === null) {
          user = {};
        }
        if (!user.launcherKey) {
          user.launcherKey = this._createArcKey();
        }
        user.id = id;
        PersistentUser.log('WRITING user (watchUser)', user);
        node.set(Arcs.utils.removeUndefined(user));
      }
      //if (!user.profiles) {
      //  node.child('profiles').push(this._createArcKey())
      //}
      PersistentUser.log('watching user', user.name, String(node));
      this._watch(node, this._remoteUserChanged.bind(this));
    }
    _remoteUserChanged(snap) {
      let user = snap.val();
      PersistentUser.log('remoteUserChanged', user);
      this._setState({user})
    }
    _watch(node, cb) {
      let watch = node.on('value', cb);
      this._off = () => node.off('value', watch);
    }
    _unwatch() {
      if (this._off) {
        this._off();
        this._off = null;
      }
    }
    get _arcsdb() {
      return db.child(`arcs`);
    }
    _createArcKey() {
      return this._arcsdb.push({}).key;
    }
    // watching arcs
    async _watchVisitedArcs(user) {
      // TODO(sjmiles): right now this information is used exclusively by the launcher, maybe
      // we only set this up conditionally?
      let nodes, onChange;
      if (user && user.arcs) {
        nodes = Object.keys(user.arcs).map(key => this._arcsdb.child(key));
        PersistentUser.log(`watching ${nodes.length} visited arc(s)`);
        // user.arcs provides user data and arc keys, combine user data with arc data from the keys
        let arcData = Object.assign(Object.create(null), user.arcs);
        onChange = snap => {
          arcData[snap.key] = snap.val();
          this._fire('arcs', arcData);
        }
      } else {
        this._fire('arcs', []);
      }
      this._watchGroup('visitedArcsGroup', nodes, onChange);
    }
    // watching views
    async _watchProfileViews(user, currentKey, arc) {
      let state = this._state;
      if (state.remoteViews) {
        state.remoteViews.forEach(rv => rv.removeEventListener('view', rv._memoListener));
      }
      // TODO(sjmiles): destroy old watch infrastructure here...
      if (user.profiles) {
        PersistentUser.log(`watchProfileViews`, user.profiles);
        state.remoteViews = Object.keys(user.profiles).map(key => {
          // TODO(sjmiles): how to make this instance go away?
          let rv = Object.assign(new RemoteViews(), {arc, key, profiles: true});
          rv._memoListener = rv.addEventListener('view', e => {
            let view = e.detail;
            PersistentUser.log(`watchProfileViews:view`, view);
            if (view.id == 'PROFILE/[Person]/friends/') {
              PersistentUser.log(`found friends view!`);
            }
          });
          return rv;
        });
      }
    }
    async _watchFriendsShareViews(user, currentKey) {
      if (user.friends) {
        // take all friend keys
        let nodes = Object.keys(user.profiles)
          // convert keys into database nodes
          .map(key => this._usersdb.child(key))
          ;
        PersistentUser.log(`watching ${nodes.length} shared arc(s)`);
        this._watchGroup('sharedViewsGroup', nodes, snap => {
          PersistentUser.log('DB->profileView::data', snap.val());
        });
      }
    }
    _watchGroup(name, nodes, cb) {
      if (this._state[name]) {
        this._state[name]();
      }
      let off = null;
      if (nodes) {
        let offs = nodes.map(node => {
          let off = node.on('value', cb);
          return () => node.off('value', off);
        });
        off = () => offs.forEach(off => off());
      }
      this._state[name] = off;
    }
  }
  PersistentUser.module = document.currentImport;
  PersistentUser.log = XenBase.logFactory('PersistentUser', '#65499c');
  customElements.define('persistent-user', PersistentUser);
})(this);
</script>
