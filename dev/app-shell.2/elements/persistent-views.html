<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<script>
  class PersistentViews extends XenBase {
    static get observedAttributes() { return ['arc','key']; }
    get _db() {
      return db.child(`arcs/${this._props.key}`);
    }
    _update(props, state, lastProps) {
      if (props.key && props.arc) { //} != lastProps.arc) {
        this._watchViews(props.arc);
      }
    }
    _watchViews(arc) {
      //PersistentViews.log('resyncing views...', arc._viewTags);
      let state = this._state;
      if (state.watchers) {
        state.watchers.forEach(w => w && w());
      }
      state.watching = new Set();
      //state.watchers = [...arc._viewTags].map((tags, view) => {
      state.watchers = [...arc._viewTags].map(([view, tags]) => {
        if (!tags || !tags.has('#nosync')) {
          return this._syncView(arc, tags, view);
        }
      });
    }
    _syncView(arc, tags, view) {
      let watching = this._state.watching;
      let viewId = this._getViewId(tags, view);
      // Make sure we only synchronize each view at most once.
      if (!watching.has(viewId)) {
        watching.add(viewId);
        // db node
        let node = this._db.child(`views/${viewId}`);
        // force latest metadata
        let metadata = {
          type: view.type || null,
          name: view.name || null,
          tags: [...tags],
        };
        node.update({metadata});
        // origination check
        let fromHere = id => id.startsWith(arc.id);
        let changedHere = data => data.length ? data.some(datum => fromHere(datum.id)) : fromHere(data.id);
        // watch the db
        node = node.child('values');
        let off = this._watchView(node, view, data => {
          if (!data || (!data.length && !data.rawData)) {
          } else {
            // only store if change DID NOT originate here
            if (!changedHere(data)) {
              PersistentViews.log(`[${viewId}] REMOTE change, updating local`, data);
              if (data.length) {
                // TODO(sjmiles): this doesn't feel right, it's likely ineffecient, but also we are
                // proliferating unique entity instances that are really just clones
                view.toList().forEach(v => view.remove(v.id));
                data.forEach(d => view.store(d));
              } else {
                view.set(Arcs.utils.removeUndefined(data));
              }
            }
          }
        });
        // watch the local view
        view.on('change', delta => {
          //PersistentViews.log('TRIGGER[local-view]: view:', delta);
          // only store if change DID originate here
          let change = delta.add || delta.remove || delta.data;
          if (changedHere(change)) {
            PersistentViews.log(`[${viewId}] LOCAL change, updating remote`, view, change);
            node.set(Arcs.utils.removeUndefined(this._getViewData(view)));
          }
        }, this);
        return off;
      }
    }
    _watchView(node, view, cb) {
      //PersistentViews.log('watching REMOTE view', node.toString());
      let handle = node.on('value', snapshot => {
        let data = snapshot.val();
        //PersistentViews.log('TRIGGER[remote-fb]: view', String(node), data);
        cb(data);
      });
      return () => node.off('value', handle);
    }
    _getViewId(tags, view) {
      let viewid = view.type.toString().replace(/ /g, '-').replace(/[\[\]]/g, '!');
      if (tags && [...tags].length) {
        viewid += '-' + [...tags][0].replace(/#/g, '');
      }
      return viewid;
    }
    _getViewData(view) {
      let data;
      if (view.toList) {
        data = view.toList();
      } else {
        let rawData = view._stored && view._stored.rawData || {};
        data = {
          id: view.id,
          rawData
        };
      }
      PersistentViews.log('view data from Arc', view, data);
      return data;
    }
  }
  PersistentViews.module = document.currentImport;
  PersistentViews.log = XenBase.logFactory('PersistentViews', '#aa00c7');
  customElements.define('persistent-views', PersistentViews);
</script>
